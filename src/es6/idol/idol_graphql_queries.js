#! /usr/bin/env node
// @flow
import { resolve } from "path";
import * as scripter from "./scripter";
import { start } from "./cli";
import { Reference } from "./js/schema/Reference";
import { Type } from "./js/schema/Type";
import {
    build,
    GeneratorAcc,
    GeneratorConfig,
    GeneratorFileContext,
    getMaterialTypeDeconstructor,
    getTagValues,
    importExpr,
    includesTag,
    Path,
    ScalarDeconstructor,
    TypeDeconstructor,
    TypeStructDeconstructor
} from "./generators";
import type { Exported, Expression, GeneratorContext } from "./generators";
import { Alt, cachedProperty, OrderedObj } from "./functional";
import { PrimitiveType } from "./js/schema/PrimitiveType";
import { TypeStruct } from "./js/schema/TypeStruct";

export class IdolGraphqlQueries implements GeneratorContext {
    config: GeneratorConfig;
    state: GeneratorAcc;
    codegenImpl: (IdolGraphqlQueries, Path, Type) => IdolGraphqlQueriesCodegenFile;
    scaffoldImpl: (IdolGraphqlQueries, Path, Type) => IdolGraphqlQueriesScaffoldFile;

    constructor(
        config: GeneratorConfig,
        codegenImpl: (IdolGraphqlQueries, Path, Type) => IdolGraphqlQueriesCodegenFile = (
            idolGraphqlQueries,
            path,
            type,
        ) => new IdolGraphqlQueriesCodegenFile(idolGraphqlQueries, path, type),
        scaffoldImpl: (IdolGraphqlQueries, Path, Type) => IdolGraphqlQueriesScaffoldFile = (
            idolGraphqlQueries,
            path,
            type,
        ) => new IdolGraphqlQueriesScaffoldFile(idolGraphqlQueries, path, type),
    ) {
        this.state = new GeneratorAcc();
        this.config = config;
        this.codegenImpl = codegenImpl;
        this.scaffoldImpl = scaffoldImpl;
    }

    codegenFile(ref: Reference): IdolGraphqlQueriesCodegenFile {
        const path = this.state.reservePath(this.config.pathsOf({ codegen: ref }));
        const type = this.config.params.allTypes.obj[ref.qualified_name];

        return cachedProperty(this, `codegenFile${path.path}`, () =>
            this.codegenImpl(this, path, type)
        );
    }

    scaffoldFile(ref: Reference): IdolGraphqlQueriesScaffoldFile {
        const path = this.state.reservePath(this.config.pathsOf({ scaffold: ref }));
        const type = this.config.params.allTypes.obj[ref.qualified_name];

        return cachedProperty(this, `scaffoldFile${path.path}`, () =>
            this.scaffoldImpl(this, path, type)
        );
    }

    get anythingGraphqlTypeName(): string {
        return "IdolGraphQLAnything";
    }

    render(): OrderedObj<string> {
        const scaffoldTypes = this.config.params.scaffoldTypes.values();
        scaffoldTypes.forEach((t, i) => {
            const scaffoldFile = this.scaffoldFile(t.named);
            if (!scaffoldFile.declaredFragments.isEmpty()) {
                console.log(
                    `Generated ${scaffoldFile.declaredFragments.unwrap().ident} (${i + 1} / ${scaffoldTypes.length})`
                );
            } else {
                console.log(`Skipped ${scaffoldFile.defaultFragmentName} (${i + 1} / ${scaffoldTypes.length})`);
            }
        });

        return this.state.render({
            codegen:
                "DO NOT EDIT\nThis file was generated by idol_graphql_queries, any changes will be overwritten when idol_graphql_queries is run again.",
            scaffold:
                "This file was scaffolded by idol_graphql_queries.  Feel free to edit as you please.  It can be regenerated by deleting the file and rerunning idol_graphql_queries."
        });
    }
}

const gql: Exported = { ident: "gql", path: new Path("graphql-tag") };

function graphqlTag(...lines: string[]): Expression {
    return (state: GeneratorAcc, path: Path) => state.importIdent(path, gql) + "`\n" + lines.join("\n") + "\n`;";
}

export class IdolGraphqlQueriesCodegenFile extends GeneratorFileContext<IdolGraphqlQueries> {
    typeDecon: TypeDeconstructor;

    constructor(idolGraphqlQueries: IdolGraphqlQueries, path: Path, type: Type) {
        super(idolGraphqlQueries, path);
        this.typeDecon = new TypeDeconstructor(type);

        this.reserveIdent(this.defaultFragmentName);
    }

    get type(): Type {
        return this.typeDecon.t;
    }

    get graphqlTypeName(): string {
        return this.type.named.asQualifiedIdent;
    }

    get defaultFragmentName(): string {
        return this.type.named.asQualifiedIdent + "Fragment";
    }

    get graphqlFieldsName(): string {
        return this.type.named.asQualifiedIdent + "Fields";
    }


    get declaredFragments(): Alt<Exported> {
        return cachedProperty(this, "declaredFragments", () => {
            return this.typeStruct.bind(ts => ts.declaredFragment)
                .either(this.struct.bind(struct => struct.declaredFragments));
        });
    }

    get struct(): Alt<IdolGraphqlQueriesCodegenStruct> {
        return cachedProperty(this, "struct", () =>
            this.typeDecon
                .getStruct()
                .map(
                    fields =>
                        new IdolGraphqlQueriesCodegenStruct(
                            this,
                            fields.map(
                                tsDecon =>
                                    new IdolGraphQLQueriesCodegenTypeStruct(this.parent, tsDecon)
                            )
                        )
                )
        );
    }

    get typeStruct(): Alt<IdolGraphqlCodegenTypeStructDeclaration> {
        return cachedProperty(this, "typeStruct", () =>
            this.typeDecon
                .getTypeStruct()
                .map(tsDecon => new IdolGraphqlCodegenTypeStructDeclaration(this, tsDecon))
        );
    }
}

export class IdolGraphqlQueriesScaffoldFile extends GeneratorFileContext<IdolGraphqlQueries> {
    typeDecon: TypeDeconstructor;
    type: Type;

    constructor(idolGraphqlQueries: IdolGraphqlQueries, path: Path, type: Type) {
        super(idolGraphqlQueries, path);
        this.typeDecon = getMaterialTypeDeconstructor(idolGraphqlQueries.config.params.allTypes, type);
        this.type = type;

        this.reserveIdent(this.defaultQueryName);
        this.reserveIdent(this.defaultMutationName);
        this.reserveIdent(this.defaultFragmentName);
    }

    defaultGraphqlTypeName(inputVariant: boolean): string {
        return this.type.named.typeName + (inputVariant ? "Input" : "");
    }

    get defaultQueryName(): string {
        return this.type.named.typeName + "Query";
    }

    get defaultMutationName(): string {
        return this.type.named.typeName + "Mutation";
    }

    get defaultFragmentName(): string {
        return this.type.named.typeName + "Fragment";
    }

    get struct(): Alt<IdolGraphqlScaffoldStruct> {
        return cachedProperty(this, "struct", () =>
            this.typeDecon
                .getStruct()
                .map(
                    fields =>
                        new (includesTag(this.type.tags, "service")
                            ? IdolGraphqlService
                            : IdolGraphqlScaffoldStruct)(
                            this,
                            fields.map(
                                tsDecon => new IdolGraphQLQueriesCodegenTypeStruct(this.parent, tsDecon)
                            )
                        )
                )
        );
    }

    get declaredFragments(): Alt<Exported> {
        return cachedProperty(this, "declaredFragments", () => {
            const codegenFile = this.parent.codegenFile(this.typeDecon.t.named);
            return codegenFile.declaredFragments.map(fragment => this.export(this.defaultFragmentName, scripter.variable(this.importIdent(fragment))))
        });
    }
}

export class IdolGraphqlQueriesCodegenStruct extends GeneratorFileContext<IdolGraphqlQueries> {
    fields: OrderedObj<IdolGraphQLQueriesCodegenTypeStruct>;
    codegenFile: IdolGraphqlQueriesCodegenFile;

    constructor(
        codegenFile: IdolGraphqlQueriesCodegenFile,
        fields: OrderedObj<IdolGraphQLQueriesCodegenTypeStruct>
    ) {
        super(codegenFile.parent, codegenFile.path);
        this.fields = fields;
        this.codegenFile = codegenFile;
    }

    get declaredFragments(): Alt<Exported> {
        return cachedProperty(this, "declaredFragments", () => {
            const fieldFragments: OrderedObj<[string, string]> = this.fields
                .mapAndFilter(codegenTypeStruct => codegenTypeStruct.fragmentExpr.bind(fragment =>
                    codegenTypeStruct.graphqlFieldsName.map(fragmentName =>
                        [fragmentName, this.applyExpr(fragment)]
                    )
                ));
            const fragments: Array<string> = Object.keys(fieldFragments.values().reduce((o, n) => {
                o[n[1]] = n;
                return o
            }, {}));


            return Alt.lift(
                this.export(this.codegenFile.defaultFragmentName, (ident: string) => [
                    scripter.comment(
                        getTagValues(this.codegenFile.typeDecon.t.tags, "description").join("\n")
                    ),
                    scripter.variable(
                        this.applyExpr(graphqlTag(
                            `fragment ${this.codegenFile.graphqlFieldsName} on ${this.codegenFile.graphqlTypeName} {`,
                            ...this.fields.concatMap(
                                (fieldName, _) => ["    " + fieldName + (fieldName in fieldFragments.obj ? `{ ...${fieldFragments.obj[fieldName][0]} }` : "")],
                                []
                            ),
                            "}",
                            ...fragments.map(fragmentIdent => "${" + fragmentIdent + "}"),
                        ))
                    )(ident)
                ])
            );
        });
    }
}

export class IdolGraphQLQueriesCodegenTypeStruct implements GeneratorContext {
    tsDecon: TypeStructDeconstructor;
    state: GeneratorAcc;
    config: GeneratorConfig;
    idolGraphqlQueries: IdolGraphqlQueries;

    constructor(idolGraphqlQueries: IdolGraphqlQueries, tsDecon: TypeStructDeconstructor) {
        this.tsDecon = tsDecon;
        this.state = idolGraphqlQueries.state;
        this.config = idolGraphqlQueries.config;
        this.idolGraphqlQueries = idolGraphqlQueries;
    }

    get fragmentExpr(): Alt<Expression> {
        return this.innerScalar.bind(scalar => scalar.fragmentExpr);
    }

    get graphqlTypeName(): Alt<string> {
        return this.tsDecon.getRepeated().bind(_ => this.innerScalar.bind(scalar => scalar.graphqlTypeName).map(s => s + "[]")).concat(this.innerScalar.bind(scalar => scalar.graphqlTypeName));
    }

    get graphqlFieldsName(): Alt<string> {
        return this.innerScalar.bind(scalar => scalar.graphqlFieldsName);
    }


    get innerScalar(): Alt<IdolGraphqlCodegenScalar> {
        return cachedProperty(this, "innerScalar", () => {
            return this.tsDecon
                .getScalar()
                .concat(this.tsDecon.getMap())
                .concat(this.tsDecon.getRepeated())
                .map(
                    scalarDecon =>
                        new IdolGraphqlCodegenScalar(this.idolGraphqlQueries, scalarDecon)
                );
        }).concat(this.tsDecon.getMap().map(map => new IdolGraphqlCodegenScalar(this.idolGraphqlQueries, new ScalarDeconstructor(
            new TypeStruct(TypeStruct.expand({ primitive_type: PrimitiveType.ANY })),
            map.context
        ))));
    }
}

export class IdolGraphqlCodegenTypeStructDeclaration extends IdolGraphQLQueriesCodegenTypeStruct {
    codegenFile: IdolGraphqlQueriesCodegenFile;

    constructor(codegenFile: IdolGraphqlQueriesCodegenFile, tsDecon: TypeStructDeconstructor) {
        super(codegenFile.parent, tsDecon);
        this.codegenFile = codegenFile;
    }

    get path(): Path {
        return this.codegenFile.path;
    }

    get export() {
        return GeneratorFileContext.prototype.export;
    }

    get applyExpr() {
        return GeneratorFileContext.prototype.applyExpr;
    }

    get declaredFragment(): Alt<Exported> {
        return cachedProperty(this, "declaredFragment", () =>
            this.fragmentExpr.map(expr => {
                return this.export(
                    this.codegenFile.defaultFragmentName,
                    scripter.commented(
                        getTagValues(this.tsDecon.context.typeTags, "description").join("\n"),
                        scripter.variable(this.applyExpr(expr))
                    )
                );
            })
        );
    }
}

export class IdolGraphqlCodegenScalar implements GeneratorContext {
    scalarDecon: ScalarDeconstructor;
    state: GeneratorAcc;
    config: GeneratorConfig;
    idolGraphqlQueries: IdolGraphqlQueries;

    constructor(idolGraphqlQueries: IdolGraphqlQueries, scalarDecon: ScalarDeconstructor) {
        this.scalarDecon = scalarDecon;
        this.state = idolGraphqlQueries.state;
        this.config = idolGraphqlQueries.config;
        this.idolGraphqlQueries = idolGraphqlQueries;

    }

    get fragmentExpr(): Alt<Expression> {
        return this.scalarDecon.getAlias().map(ref => getMaterialTypeDeconstructor(
            this.config.params.allTypes,
            this.config.params.allTypes.obj[ref.qualified_name]
        )).bind(tDecon => this.idolGraphqlQueries.codegenFile(tDecon.t.named).declaredFragments.map(importExpr));
    }

    get graphqlFieldsName(): Alt<string> {
        return this.scalarDecon.getAlias().map(ref => getMaterialTypeDeconstructor(
            this.config.params.allTypes,
            this.config.params.allTypes.obj[ref.qualified_name]
        )).map(tDecon => this.idolGraphqlQueries.codegenFile(tDecon.t.named).graphqlFieldsName);
    }

    get graphqlTypeName(): Alt<string> {
        return this.scalarDecon.getPrimitive().map(prim => {
            if (prim === PrimitiveType.ANY) {
                return this.idolGraphqlQueries.anythingGraphqlTypeName;
            } else if (prim === PrimitiveType.BOOL) {
                return "GraphQLBoolean";
            } else if (prim === PrimitiveType.DOUBLE) {
                return "GraphQLFloat";
            } else if (prim === PrimitiveType.INT) {
                return "GraphQLInt";
            } else if (prim === PrimitiveType.STRING) {
                return "GraphQLString";
            }

            throw new Error(`Unexpected primitive type ${prim}`);
        });
    }
}

export class IdolGraphqlScaffoldStruct extends GeneratorFileContext<IdolGraphqlQueries> {
    fields: OrderedObj<IdolGraphQLQueriesCodegenTypeStruct>;
    codegenFile: IdolGraphqlQueriesCodegenFile;
    scaffoldFile: IdolGraphqlQueriesScaffoldFile;

    constructor(
        scaffoldFile: IdolGraphqlQueriesScaffoldFile,
        fields: OrderedObj<IdolGraphQLQueriesCodegenTypeStruct>
    ) {
        super(scaffoldFile.parent, scaffoldFile.path);
        this.fields = fields;
        this.scaffoldFile = scaffoldFile;
        this.codegenFile = this.parent.codegenFile(
            this.scaffoldFile.typeDecon.t.named,
        );
    }

    get fragmentsExpr(): Alt<Expression> {
        return this.codegenFile.declaredFragments.map(importExpr);
    }

    get declaredFragments(): Alt<Exported> {
        return cachedProperty(this, "declaredFragments", () => {
            return this.fragmentsExpr.map(fragments =>
                this.export(
                    this.scaffoldFile.defaultFragmentName,
                    scripter.variable(this.applyExpr(fragments))
                )
            );
        });
    }
}

export class IdolGraphqlService extends IdolGraphqlScaffoldStruct {
    fields: OrderedObj<IdolGraphQLQueriesCodegenTypeStruct>;
    codegenFile: IdolGraphqlQueriesCodegenFile;
}

export class IdolGraphqlMethod implements GeneratorContext {
    tDecon: TypeDeconstructor;
    state: GeneratorAcc;
    config: GeneratorConfig;
    idolGraphqlQueries: IdolGraphqlQueries;

    constructor(idolGraphqlQueries: IdolGraphqlQueries, tDecon: TypeDeconstructor) {
        this.tDecon = tDecon;
        this.state = idolGraphqlQueries.state;
        this.config = idolGraphqlQueries.config;
        this.idolGraphqlQueries = idolGraphqlQueries;
    }

    get methodExpr(): Alt<Expression> {
        return this.tDecon.getStruct().bind(fields => {
            const outputTypeExpr: Alt<Expression> = fields
                .get("output")
                .bind(
                    outputTs => new IdolGraphQLQueriesCodegenTypeStruct(this.idolGraphqlQueries, outputTs, false).typeExpr
                );
            const inputFields: Alt<Exported> = fields
                .get("input")
                .bind(inputTs => inputTs.getScalar().bind(scalar => scalar.getAlias()))
                .bind(ref => {
                    const materialType = getMaterialTypeDeconstructor(
                        this.config.params.allTypes,
                        this.config.params.allTypes.obj[ref.qualified_name]
                    );
                    return this.idolGraphqlQueries
                        .codegenFile(materialType.t.named, true)
                        .struct.bind(struct => struct.declaredFields);
                });

            if (outputTypeExpr.isEmpty() || inputFields.isEmpty()) {
                throw new Error(
                    "GraphQL methods required input and output fields, which must be structs with fields."
                );
            }

            return outputTypeExpr.bind(output =>
                inputFields.map(inputFields => (state: GeneratorAcc, path: Path) =>
                    scripter.objLiteral(
                        scripter.propDec("type", output(state, path)),
                        scripter.propDec(
                            "resolve",
                            scripter.arrowFunc(["root", "args", "context"], scripter.literal(null))
                        ),
                        scripter.propDec(
                            "args",
                            scripter.objLiteral(scripter.spread(state.importIdent(path, inputFields)))
                        ),
                        scripter.propDec(
                            "description",
                            scripter.literal(getTagValues(this.tDecon.t.tags, "description").join("\n"))
                        )
                    )
                )
            );
        });
    }
}

function main() {
    const params = start({
        flags: {},
        args: {
            target: "idol module names whose contents will have extensible types scaffolded.",
            output: "a directory to generate the scaffolds and codegen into."
        }
    });

    const config = new GeneratorConfig(params);
    config.withPathMappings({
        codegen: config.inCodegenDir(GeneratorConfig.oneFilePerType),
        scaffold: GeneratorConfig.oneFilePerType
    });

    const idolGraphqlQueries = new IdolGraphqlQueries(config);
    const moveTo = build(config, idolGraphqlQueries.render());
    moveTo(params.outputDir);
}

if (require.main === module) {
    main();
}
