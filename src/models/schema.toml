[StructKind]
# Scalars are non contained values
# Repeated are essentially lists.  They can be upgraded or downgraded to and from Scalars.
#   A repeated is indicated in a TypeDec by ending with '[]'
# Maps are 'dictionaries', whose key is always a string, mapping to js objects.
#   A map is indicated in a TypeDec by ending with '{}'
enum = ["Scalar", "Repeated", "Map"]

[PrimitiveType]
# int53 and int64 are both signed.
# int53 is intended to fit into Javascript's Number natively without losing precision.
# int64 is intended to possibly contain values greater than Javascript's native Number precision.
#   codegen support int64 will need to consider carefully how to serialize these values for their
#   target environment.  Usually this means serializing them as a string.
enum = ["int53", "int64", "double", "string", "bool", "any"]

[Dependency.fields]
# The external type name required by the from type
to = "Reference"
# The information on the type needing the to type.
from = "Reference"
# Convenience attribute indicating when the module for the from and to are equal.
is_local = "bool"
# True when the to reference is a higher kinded type (should take type_vars).
is_abstraction = "bool"

[Reference.fields]
# The module_name.type_name string
qualified_name = "string"
# Just the type name
type_name = "string"
# Just the module name
module_name = "string"

[Type.fields]
# Set when this is type is an alias or simply an type expression (such as a generic).
# Exclusive with having values for options or fields.
is_a = ["TypeStruct", "optional"]
# When this type is a struct, each of its fields and the type of that field is included
# Exclusive with is_a and options
fields = "Field{}"
# When this type is an enum includes the string values for each enum entry.  Note that each
# target language may have different rules for the enum constant names, but these entries are
# canonical resident values.
# Exclusive with is_a and fields.
options = "string[]"
# General metadata given to a type.  Currently, atleast_one for Repeated types is supported.
# Custom codegen can use these tags to implement semantic types on top of simple logic types.
# In general, however, tags are considred optional and should not be required to
# deserialize / serializeconsume correct logical values.
tags = "string[]"
# For high order kinds (generics) that target other types as arguments, each of these strings
# is a local alias for the parameter at that position.
# ie: if MyMap.type_vars = ["A", "B"] then MyMap<int53, string> will replace all "A" and "B" references
# inside of MyMap with int53 and string.
type_vars = "string[]"
# The name and module information of this type's definition.
named = "Reference"
# The dependencies found in this type's is_a or fields.
dependencies = "Dependency[]"


[Module.fields]
module_name = "string"
dependencies = "Dependency[]"
types_by_name = "Type{}"
types_dependency_ordering = "string[]"
abstract_types_by_name = "Type{}"

[TypeStruct.fields]
struct_kind = "StructKind"
reference = "Reference"
primitive_type = "PrimitiveType"
literal = ["Literal", "optional"]
parameters = "Reference[]"

[Literal.fields]
int64 = "int64"
int53 = "int53"
double = "double"
string = "string"
bool = "bool"


[Field.fields]
field_name = "string"
tags = "string[]"
type_struct = "TypeStruct"