#! /usr/bin/env node
// @flow
import { resolve } from "path";
import * as scripter from "./scripter";
import { start } from "./cli";
import { Reference } from "./js/schema/Reference";
import { Type } from "./js/schema/Type";
import {
  build,
  GeneratorAcc,
  GeneratorConfig,
  GeneratorFileContext,
  getMaterialTypeDeconstructor,
  getTagValues,
  importExpr,
  includesTag,
  Path,
  ScalarDeconstructor,
  TypeDeconstructor,
  TypeStructDeconstructor
} from "./generators";
import type { Exported, Expression, GeneratorContext } from "./generators";
import { Alt, cachedProperty, OrderedObj } from "./functional";
import { PrimitiveType } from "./js/schema/PrimitiveType";

export class IdolGraphqlQueries implements GeneratorContext {
  config: GeneratorConfig;
  state: GeneratorAcc;
  codegenImpl: (IdolGraphqlQueries, Path, Type) => IdolGraphqlQueriesCodegenFile;
  scaffoldImpl: (IdolGraphqlQueries, Path, Type) => IdolGraphqlQueriesScaffoldFile;

  constructor(
    config: GeneratorConfig,
    codegenImpl: (IdolGraphqlQueries, Path, Type) => IdolGraphqlQueriesCodegenFile = (
      idolGraphqlQueries,
      path,
      type,
    ) => new IdolGraphqlQueriesCodegenFile(idolGraphqlQueries, path, type),
    scaffoldImpl: (IdolGraphqlQueries, Path, Type) => IdolGraphqlQueriesCodegenFile = (
        idolGraphqlQueries,
        path,
        type,
    ) => new IdolGraphqlQueriesScaffoldFile(idolGraphqlQueries, path, type),
  ) {
    this.state = new GeneratorAcc();
    this.config = config;
    this.codegenImpl = codegenImpl;
    this.scaffoldImpl = scaffoldImpl;
  }

  codegenFile(ref: Reference): IdolGraphqlQueriesCodegenFile {
    const path = this.state.reservePath(this.config.pathsOf({ codegen: ref }));
    const type = this.config.params.allTypes.obj[ref.qualified_name];

    return cachedProperty(this, `codegenFile${path.path}`, () =>
      this.codegenImpl(this, path, type)
    );
  }

  scaffoldFile(ref: Reference): IdolGraphqlQueriesScaffoldFile {
    const path = this.state.reservePath(this.config.pathsOf({ scaffold: ref }));
    const type = this.config.params.allTypes.obj[ref.qualified_name];

    return cachedProperty(this, `scaffoldFile${path.path}`, () =>
      this.scaffoldImpl(this, path, type)
    );
  }

  render(): OrderedObj<string> {
    const scaffoldTypes = this.config.params.scaffoldTypes.values();
    scaffoldTypes.forEach((t, i) => {
      const scaffoldFile = this.scaffoldFile(t.named, false);
      if (!scaffoldFile.declaredTypeIdent.isEmpty()) {
        console.log(
          `Generated ${scaffoldFile.defaultTypeName} (${i + 1} / ${scaffoldTypes.length})`
        );
      } else {
        console.log(`Skipped ${scaffoldFile.defaultTypeName} (${i + 1} / ${scaffoldTypes.length})`);
      }
    });

    return this.state.render({
      codegen:
        "DO NOT EDIT\nThis file was generated by idol_graphql_queries, any changes will be overwritten when idol_graphql_queries is run again.",
      scaffold:
        "This file was scaffolded by idol_graphql_queries.  Feel free to edit as you please.  It can be regenerated by deleting the file and rerunning idol_graphql_queries."
    });
  }
}

const gql: Exported = { ident: "gql", path: new Path("graphql-tag") };
function graphqlTag(...lines: string[]): Expression {
  return (state: GeneratorAcc, path: Path) => state.importIdent(path, gql) + "`" + lines.join("\n") + "`;";
}

export class IdolGraphqlQueriesCodegenFile extends GeneratorFileContext<IdolGraphqlQueries> {
  typeDecon: TypeDeconstructor;
  inputTypeVariant: boolean;

  constructor(idolGraphqlQueries: IdolGraphqlQueries, path: Path, type: Type) {
    super(idolGraphqlQueries, path);
    this.typeDecon = new TypeDeconstructor(type);

    this.reserveIdent(this.defaultTypeIdentName);
  }

  get type(): Type {
    return this.typeDecon.t;
  }

  get defaultTypeIdentName(): string {
    return this.defaultTypeName + "Type";
  }

  get defaultTypeName(): string {
    return this.type.named.asQualifiedIdent + (this.inputTypeVariant ? "Input" : "");
  }

  get defaultGraphQLTypeName(): string {
    if (this.type.named.qualifiedName in this.config.params.scaffoldTypes.obj) {
      return this.parent.defaultGraphqlTypeName(this.type, this.inputTypeVariant);
    }

    return this.defaultTypeName;
  }

  get defaultFieldsName(): string {
    return this.type.named.asQualifiedIdent + (this.inputTypeVariant ? "InputFields" : "Fields");
  }

  get defaultEnumName(): string {
    return this.type.named.asQualifiedIdent;
  }

  get declaredTypeIdent(): Alt<Exported> {
    return cachedProperty(this, "declaredTypeIdent", () => {
      return this.enum
        .bind(e => e.declaredType)
        .either(this.typeStruct.bind(ts => ts.declaredType))
        .either(this.struct.bind(struct => struct.declaredType));
    });
  }

  get struct(): Alt<IdolGraphqlCodegenStruct> {
    return cachedProperty(this, "struct", () =>
      this.typeDecon
        .getStruct()
        .map(
          fields =>
            new IdolGraphqlCodegenStruct(
              this,
              fields.map(
                tsDecon =>
                  new IdolGraphQLCodegenTypeStruct(this.parent, tsDecon, this.inputTypeVariant)
              )
            )
        )
    );
  }

  get enum(): Alt<IdolGraphqlCodegenEnum> {
    return cachedProperty(this, "enum", () =>
      this.typeDecon.getEnum().map(options => new IdolGraphqlCodegenEnum(this, options))
    );
  }

  get typeStruct(): Alt<IdolGraphqlCodegenTypeStructDeclaration> {
    return cachedProperty(this, "typeStruct", () =>
      this.typeDecon
        .getTypeStruct()
        .map(tsDecon => new IdolGraphqlCodegenTypeStructDeclaration(this, tsDecon))
    );
  }
}

export class IdolGraphqlQueriesScaffoldFile extends GeneratorFileContext<IdolGraphqlQueries> {
  typeDecon: TypeDeconstructor;
  type: Type;

  constructor(idolGraphqlQueries: IdolGraphqlQueries, path: Path, type: Type) {
    super(idolGraphqlQueries, path);
    this.typeDecon = getMaterialTypeDeconstructor(idolGraphqlQueries.config.params.allTypes, type);
    this.type = type;

    this.reserveIdent(this.defaultTypeIdentName);
  }

  get defaultTypeIdentName() {
    return this.defaultTypeName + "Type";
  }

  get defaultTypeName() {
    return this.parent.defaultGraphqlTypeName(this.type, this.inputVariant);
  }

  // Used exclusively by services.
  get defaultQueriesName(): string {
    return this.type.named.typeName + "Queries";
  }

  get struct(): Alt<IdolGraphqlScaffoldStruct> {
    return cachedProperty(this, "struct", () =>
      this.typeDecon
        .getStruct()
        .map(
          fields =>
            new (includesTag(this.type.tags, "service")
              ? IdolGraphqlService
              : IdolGraphqlScaffoldStruct)(
              this,
              fields.map(
                tsDecon => new IdolGraphQLCodegenTypeStruct(this.parent, tsDecon, this.inputVariant)
              )
            )
        )
    );
  }

  get declaredTypeIdent(): Alt<Exported> {
    return cachedProperty(this, "declaredTypeIdent", () => {
      const codegenFile = this.parent.codegenFile(this.typeDecon.t.named, this.inputVariant);
      return this.struct
        .bind(struct => struct.declaredType)
        .either(
          codegenFile.typeStruct
            .bind(ts => ts.declaredType)
            .either(codegenFile.enum.bind(e => e.declaredType))
            .map(declaredType => scripter.variable(this.importIdent(declaredType)))
            .map(scriptable => this.export(this.defaultTypeIdentName, scriptable))
        );
    });
  }
}

export class IdolGraphqlCodegenStruct extends GeneratorFileContext<IdolGraphqlQueries> {
  fields: OrderedObj<IdolGraphQLCodegenTypeStruct>;
  codegenFile: IdolGraphqlQueriesCodegenFile;

  constructor(
    codegenFile: IdolGraphqlQueriesCodegenFile,
    fields: OrderedObj<IdolGraphQLCodegenTypeStruct>
  ) {
    super(codegenFile.parent, codegenFile.path);
    this.fields = fields;
    this.codegenFile = codegenFile;
  }

  get declaredFields(): Alt<Exported> {
    return cachedProperty(this, "declaredFields", () => {
      const fieldTypes: OrderedObj<string> = this.fields
        .mapAndFilter(codegenTypeStruct => codegenTypeStruct.typeExpr)
        .map(expr => this.applyExpr(expr));

      return Alt.lift(
        this.export(this.codegenFile.defaultFieldsName, (ident: string) => [
          scripter.comment(
            getTagValues(this.codegenFile.typeDecon.t.tags, "description").join("\n")
          ),
          scripter.variable(
            scripter.objLiteral(
              ...fieldTypes.concatMap(
                (fieldName, fieldType) => [
                  scripter.propDec(
                    fieldName,
                    scripter.objLiteral(
                      scripter.propDec("type", fieldType),
                      scripter.propDec(
                        "description",
                        scripter.literal(
                          getTagValues(
                            this.fields.obj[fieldName].tsDecon.context.fieldTags,
                            "description"
                          ).join("\n")
                        )
                      )
                    )
                  )
                ],
                []
              )
            )
          )(ident)
        ])
      );
    });
  }

  get declaredType(): Alt<Exported> {
    return cachedProperty(this, "declaredType", () => {
      return this.declaredFields.map(declaredFields =>
        this.export(
          this.codegenFile.defaultTypeIdentName,
          scripter.variable(
            "new " +
              scripter.invocation(
                this.importIdent(
                  exportedFromGraphQL(
                    this.codegenFile.inputTypeVariant
                      ? "GraphQLInputObjectType"
                      : "GraphQLObjectType"
                  )
                ),
                scripter.objLiteral(
                  scripter.propDec(
                    "name",
                    scripter.literal(this.codegenFile.defaultGraphQLTypeName)
                  ),
                  scripter.propDec(
                    "description",
                    scripter.literal(
                      getTagValues(this.codegenFile.typeDecon.t.tags, "description").join("\n")
                    )
                  ),
                  scripter.propDec(
                    "fields",
                    scripter.objLiteral(scripter.spread(this.importIdent(declaredFields)))
                  )
                )
              )
          )
        )
      );
    });
  }
}

export class IdolGraphqlCodegenEnum extends GeneratorFileContext<IdolGraphqlQueries> {
  options: string[];
  codegenFile: IdolGraphqlQueriesCodegenFile;

  constructor(codegenFile: IdolGraphqlQueriesCodegenFile, options: string[]) {
    super(codegenFile.parent, codegenFile.path);
    this.codegenFile = codegenFile;
    this.options = options;
  }

  get declaredEnum(): Alt<Exported> {
    return cachedProperty(this, "declaredEnum", () =>
      Alt.lift(
        this.export(this.codegenFile.defaultEnumName, ident => [
          scripter.comment(
            getTagValues(this.codegenFile.typeDecon.t.tags, "description").join("\n")
          ),
          scripter.variable(
            scripter.objLiteral(
              ...this.options.map(option =>
                scripter.propDec(option.toUpperCase(), scripter.literal(option))
              )
            )
          )(ident)
        ])
      )
    );
  }

  get declaredType(): Alt<Exported> {
    return cachedProperty(this, "declaredType", () =>
      this.declaredEnum.map(declaredEnum =>
        this.export(this.codegenFile.defaultTypeIdentName, ident => [
          scripter.variable(
            "new " +
              scripter.invocation(
                this.importIdent(exportedFromGraphQL("GraphQLEnumType")),
                scripter.objLiteral(
                  scripter.propDec(
                    "name",
                    scripter.literal(this.codegenFile.defaultGraphQLTypeName)
                  ),
                  scripter.propDec(
                    "description",
                    scripter.literal(
                      getTagValues(this.codegenFile.typeDecon.t.tags, "description").join("\n")
                    )
                  ),
                  scripter.propDec(
                    "values",
                    scripter.invocation(
                      this.importIdent(this.codegenFile.parent.idolGraphQlFile.wrapValues),
                      this.importIdent(declaredEnum)
                    )
                  )
                )
              )
          )(ident)
        ])
      )
    );
  }
}

export class IdolGraphQLCodegenTypeStruct implements GeneratorContext {
  tsDecon: TypeStructDeconstructor;
  state: GeneratorAcc;
  config: GeneratorConfig;
  idolGraphqlQueries: IdolGraphqlQueries;
  inputVariant: boolean;

  constructor(idolGraphqlQueries: IdolGraphqlQueries, tsDecon: TypeStructDeconstructor, inputVariant: boolean) {
    this.tsDecon = tsDecon;
    this.state = idolGraphqlQueries.state;
    this.config = idolGraphqlQueries.config;
    this.idolGraphqlQueries = idolGraphqlQueries;
    this.inputVariant = inputVariant;
  }

  get typeExpr(): Alt<Expression> {
    return this.scalarTypeExpr.concat(this.collectionTypeExpr);
  }

  get scalarTypeExpr(): Alt<Expression> {
    if (this.tsDecon.getScalar().isEmpty()) return Alt.empty();
    return this.innerScalar.bind(scalar => scalar.typeExpr);
  }

  get mapTypeExpr(): Alt<Expression> {
    return this.tsDecon.getMap().map(() => importExpr(this.idolGraphqlQueries.idolGraphQlFile.Anything));
  }

  get repeatedTypeExpr(): Alt<Expression> {
    return this.tsDecon
      .getRepeated()
      .bind(() => this.innerScalar.bind(innerScalar => innerScalar.typeExpr))
      .map(scalarExpr => (state: GeneratorAcc, path: Path): string =>
        "new " +
        scripter.invocation(
          state.importIdent(path, exportedFromGraphQL("GraphQLList")),
          scalarExpr(state, path)
        )
      );
  }

  get collectionTypeExpr(): Alt<Expression> {
    return this.mapTypeExpr.either(this.repeatedTypeExpr);
  }

  get innerScalar(): Alt<IdolGraphqlCodegenScalar> {
    return cachedProperty(this, "innerScalar", () => {
      return this.tsDecon
        .getScalar()
        .concat(this.tsDecon.getMap())
        .concat(this.tsDecon.getRepeated())
        .map(
          scalarDecon =>
            new IdolGraphqlCodegenScalar(this.idolGraphqlQueries, scalarDecon, this.inputVariant)
        );
    });
  }
}

export class IdolGraphqlCodegenTypeStructDeclaration extends IdolGraphQLCodegenTypeStruct {
  codegenFile: IdolGraphqlQueriesCodegenFile;

  constructor(codegenFile: IdolGraphqlQueriesCodegenFile, tsDecon: TypeStructDeconstructor) {
    super(codegenFile.parent, tsDecon, codegenFile.inputTypeVariant);
    this.codegenFile = codegenFile;
  }

  get path(): Path {
    return this.codegenFile.path;
  }

  get export() {
    return GeneratorFileContext.prototype.export;
  }

  get applyExpr() {
    return GeneratorFileContext.prototype.applyExpr;
  }

  get declaredType(): Alt<Exported> {
    return cachedProperty(this, "declaredType", () =>
      this.typeExpr.map(expr => {
        return this.export(
          this.codegenFile.defaultTypeIdentName,
          scripter.commented(
            getTagValues(this.tsDecon.context.typeTags, "description").join("\n"),
            scripter.variable(this.applyExpr(expr))
          )
        );
      })
    );
  }

  get scalarTypeExpr(): Alt<Expression> {
    if (this.tsDecon.getScalar().isEmpty()) return Alt.empty();
    return super.scalarTypeExpr.either(this.literalTypeExpr);
  }

  get literalTypeExpr(): Alt<Expression> {
    return this.tsDecon
      .getScalar()
      .bind(scalar => scalar.getLiteral())
      .map(([_, val]) => (state: GeneratorAcc, path: Path) => {
        return scripter.invocation(
          state.importIdent(path, this.idolGraphqlQueries.idolGraphQlFile.LiteralTypeOf),
          scripter.literal(this.codegenFile.defaultTypeName),
          scripter.literal(val),
          scripter.literal(getTagValues(this.tsDecon.context.typeTags, "description").join("\n"))
        );
      });
  }
}

export class IdolGraphqlCodegenScalar implements GeneratorContext {
  scalarDecon: ScalarDeconstructor;
  state: GeneratorAcc;
  config: GeneratorConfig;
  idolGraphqlQueries: IdolGraphqlQueries;
  inputVariant: boolean;

  constructor(idolGraphqlQueries: IdolGraphqlQueries, scalarDecon: ScalarDeconstructor, inputVariant: boolean) {
    this.scalarDecon = scalarDecon;
    this.state = idolGraphqlQueries.state;
    this.config = idolGraphqlQueries.config;
    this.idolGraphqlQueries = idolGraphqlQueries;
    this.inputVariant = inputVariant;
  }

  get typeExpr(): Alt<Expression> {
    return this.referenceImportExpr.either(this.primTypeExpr);
  }

  get referenceImportExpr(): Alt<Expression> {
    const aliasScaffoldFile = this.scalarDecon
      .getAlias()
      .filter(ref => ref.qualified_name in this.config.params.scaffoldTypes.obj)
      .map(ref => this.idolGraphqlQueries.scaffoldFile(ref, this.inputVariant));

    if (aliasScaffoldFile.isEmpty()) {
      const aliasCodegenFile = this.scalarDecon
        .getAlias()
        .map(ref => this.idolGraphqlQueries.codegenFile(ref, this.inputVariant));
      return aliasCodegenFile
        .bind(codegenFile => codegenFile.declaredTypeIdent)
        .map(codegenType => importExpr(codegenType, "Codegen" + codegenType.ident));
    }

    return aliasScaffoldFile
      .bind(scaffoldFile => scaffoldFile.declaredTypeIdent)
      .map(scaffoldType => importExpr(scaffoldType, "Scaffold" + scaffoldType.ident));
  }

  get primTypeExpr(): Alt<Expression> {
    return this.scalarDecon.getPrimitive().map(prim => {
      if (prim === PrimitiveType.ANY) {
        return importExpr(this.idolGraphqlQueries.idolGraphQlFile.Anything);
      } else if (prim === PrimitiveType.BOOL) {
        return importExpr(exportedFromGraphQL("GraphQLBoolean"));
      } else if (prim === PrimitiveType.DOUBLE) {
        return importExpr(exportedFromGraphQL("GraphQLFloat"));
      } else if (prim === PrimitiveType.INT) {
        return importExpr(exportedFromGraphQL("GraphQLInt"));
      } else if (prim === PrimitiveType.STRING) {
        return importExpr(exportedFromGraphQL("GraphQLString"));
      }

      throw new Error(`Unexpected primitive type ${prim}`);
    });
  }
}

export class IdolGraphqlScaffoldStruct extends GeneratorFileContext<IdolGraphqlQueries> {
  fields: OrderedObj<IdolGraphQLCodegenTypeStruct>;
  codegenFile: IdolGraphqlQueriesCodegenFile;
  scaffoldFile: IdolGraphqlQueriesScaffoldFile;

  constructor(
    scaffoldFile: IdolGraphqlQueriesScaffoldFile,
    fields: OrderedObj<IdolGraphQLCodegenTypeStruct>
  ) {
    super(scaffoldFile.parent, scaffoldFile.path);
    this.fields = fields;
    this.scaffoldFile = scaffoldFile;
    this.codegenFile = this.parent.codegenFile(
      this.scaffoldFile.typeDecon.t.named,
      this.scaffoldFile.inputVariant
    );
  }

  get declaredFields(): Alt<Expression> {
    return this.codegenFile.struct.bind(struct => struct.declaredFields).map(importExpr);
  }

  get declaredType(): Alt<Exported> {
    return cachedProperty(this, "declaredType", () => {
      return this.declaredFields.map(declaredFields =>
        this.export(
          this.scaffoldFile.defaultTypeIdentName,
          scripter.variable(
            "new " +
              scripter.invocation(
                this.importIdent(
                  exportedFromGraphQL(
                    this.scaffoldFile.inputVariant ? "GraphQLInputObjectType" : "GraphQLObjectType"
                  )
                ),
                scripter.objLiteral(
                  scripter.propDec("name", scripter.literal(this.scaffoldFile.defaultTypeName)),
                  scripter.propDec(
                    "description",
                    scripter.literal(
                      getTagValues(this.scaffoldFile.typeDecon.t.tags, "description").join("\n")
                    )
                  ),
                  scripter.propDec(
                    "fields",
                    scripter.objLiteral(scripter.spread(this.applyExpr(declaredFields)))
                  )
                )
              )
          )
        )
      );
    });
  }
}

export class IdolGraphqlService extends IdolGraphqlScaffoldStruct {
  fields: OrderedObj<IdolGraphQLCodegenTypeStruct>;
  codegenFile: IdolGraphqlQueriesCodegenFile;

  get declaredFields(): Alt<Expression> {
    return cachedProperty(this, "declaredFields", () => {
      const methods: OrderedObj<string> = this.fields
        .mapAndFilter(codegenTypeStruct =>
          codegenTypeStruct.tsDecon
            .getScalar()
            .bind(scalar => scalar.getAlias())
            .map(ref =>
              getMaterialTypeDeconstructor(
                this.config.params.allTypes,
                this.config.params.allTypes.obj[ref.qualified_name]
              )
            )
            .bind(tDecon => new IdolGraphqlMethod(this.parent, tDecon).methodExpr)
        )
        .map(expr => this.applyExpr(expr));

      return Alt.lift(
        this.export(this.scaffoldFile.defaultQueriesName, (ident: string) => [
          scripter.comment(getTagValues(this.scaffoldFile.type.tags, "description").join("\n")),
          scripter.variable(
            scripter.objLiteral(
              ...methods.concatMap((fieldName, method) => [scripter.propDec(fieldName, method)], [])
            )
          )(ident)
        ])
      ).map(importExpr);
    });
  }
}

export class IdolGraphqlMethod implements GeneratorContext {
  tDecon: TypeDeconstructor;
  state: GeneratorAcc;
  config: GeneratorConfig;
  idolGraphqlQueries: IdolGraphqlQueries;

  constructor(idolGraphqlQueries: IdolGraphqlQueries, tDecon: TypeDeconstructor) {
    this.tDecon = tDecon;
    this.state = idolGraphqlQueries.state;
    this.config = idolGraphqlQueries.config;
    this.idolGraphqlQueries = idolGraphqlQueries;
  }

  get methodExpr(): Alt<Expression> {
    return this.tDecon.getStruct().bind(fields => {
      const outputTypeExpr: Alt<Expression> = fields
        .get("output")
        .bind(
          outputTs => new IdolGraphQLCodegenTypeStruct(this.idolGraphqlQueries, outputTs, false).typeExpr
        );
      const inputFields: Alt<Exported> = fields
        .get("input")
        .bind(inputTs => inputTs.getScalar().bind(scalar => scalar.getAlias()))
        .bind(ref => {
          const materialType = getMaterialTypeDeconstructor(
            this.config.params.allTypes,
            this.config.params.allTypes.obj[ref.qualified_name]
          );
          return this.idolGraphqlQueries
            .codegenFile(materialType.t.named, true)
            .struct.bind(struct => struct.declaredFields);
        });

      if (outputTypeExpr.isEmpty() || inputFields.isEmpty()) {
        throw new Error(
          "GraphQL methods required input and output fields, which must be structs with fields."
        );
      }

      return outputTypeExpr.bind(output =>
        inputFields.map(inputFields => (state: GeneratorAcc, path: Path) =>
          scripter.objLiteral(
            scripter.propDec("type", output(state, path)),
            scripter.propDec(
              "resolve",
              scripter.arrowFunc(["root", "args", "context"], scripter.literal(null))
            ),
            scripter.propDec(
              "args",
              scripter.objLiteral(scripter.spread(state.importIdent(path, inputFields)))
            ),
            scripter.propDec(
              "description",
              scripter.literal(getTagValues(this.tDecon.t.tags, "description").join("\n"))
            )
          )
        )
      );
    });
  }
}

function main() {
  const params = start({
    flags: {},
    args: {
      target: "idol module names whose contents will have extensible types scaffolded.",
      output: "a directory to generate the scaffolds and codegen into."
    }
  });

  const config = new GeneratorConfig(params);
  config.withPathMappings({
    codegen: config.inCodegenDir(GeneratorConfig.oneFilePerType),
    scaffold: GeneratorConfig.oneFilePerType
  });

  const idolGraphqlQueries = new IdolGraphqlQueries(config);
  const moveTo = build(config, idolGraphqlQueries.render());
  moveTo(params.outputDir);
}

if (require.main === module) {
  main();
}
