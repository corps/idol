#! /usr/bin/env python3

import os.path

from cached_property import cached_property
from typing import Callable, Any, List, Dict

from idol import scripter
from idol.cli import start, CliConfig
from idol.functional import OrderedObj, Disjoint, Alt
from idol.generator import (
    GeneratorParams,
    GeneratorConfig,
    build,
    GeneratorAcc,
    TypeDeconstructor,
    Path,
    get_material_type_deconstructor,
    TypeStructDeconstructor,
    ScalarDeconstructor,
    GeneratorContext,
    GeneratorFileContext,
    Exported,
)
from idol.schema import *

ExportedAny: Exported = Exported(Path("typing"), "Any")


class IdolPy(GeneratorContext):
    scaffolds: Dict[str, "IdolPyScaffoldFile"]
    codegens: Dict[str, "IdolPyCodegenFile"]
    scaffold_impl: "Callable[[IdolPy, Type, Path], IdolPyScaffoldFile]"
    codegen_impl: "Callable[[IdolPy, Type, Path], IdolPyCodegenFile]"

    def __init__(
            self,
            config: GeneratorConfig,
            scaffold_impl: "Callable[[IdolPy, Type, Path], IdolPyScaffoldFile]" = None,
            codegen_impl: "Callable[[IdolPy, Type, Path], IdolPyCodegenFile]" = None,
    ):
        super(IdolPy, self).__init__(GeneratorAcc(), config)
        self.scaffolds = {}
        self.codegens = {}
        self.scaffold_impl = scaffold_impl or IdolPyScaffoldFile
        self.codegen_impl = codegen_impl or IdolPyCodegenFile

    def scaffold_file(self, ref: Reference) -> "IdolPyScaffoldFile":
        path = self.state.reserve_path(**self.config.paths_of(scaffold=ref))
        t = self.config.params.all_types[ref.qualified_name]
        scaffold_file = self.scaffold_impl(self, t, path)
        return self.scaffolds.setdefault(ref.qualified_name, scaffold_file)

    def codegen_file(self, ref: Reference) -> "IdolPyCodegenFile":
        path = self.state.reserve_path(**self.config.paths_of(codegen=ref))
        t = self.config.params.all_types[ref.qualified_name]
        codegen_file = self.codegen_impl(self, t, path)
        return self.codegens.setdefault(ref.qualified_name, codegen_file)

    @cached_property
    def idol_py_file(self) -> "IdolPyFile":
        path = self.state.reserve_path(runtime=self.config.codegen_root + "/__idol__.py")
        return IdolPyFile(self, path)

    def render(self) -> OrderedObj[str]:
        for i, t in enumerate(self.config.params.scaffold_types):
            print(
                f"Rendered {self.scaffold_file(t.named).exported_type_ident} ({i} / {len(self.config.params.scaffold_types)})")

        return self.state.render(dict(codegen=[
            "DO NOT EDIT",
            "This file was generated by idol_py, any changes will be lost when idol_py is rerun again"
        ], scaffold=[
            "This file was scaffold by idol_py, but it will not be overwritten, so feel free to edit.",
            "This file will be regenerated if you delete it.",
        ]))


class IdolPyCodegenFile(GeneratorFileContext):
    t: Type
    idol_py: IdolPy
    t_decon: TypeDeconstructor

    def __init__(self, idol_py: IdolPy, t: Type, path: Path):
        self.t = t
        self.idol_py = idol_py
        self.t_decon = TypeDeconstructor(t)
        super(IdolPyCodegenFile, self).__init__(idol_py, path)

    @cached_property
    def declared_type_ident(self) -> Alt[Exported]:
        type_ident: Alt[Exported] = Alt(
            v for typestruct in self.typestruct for v in typestruct.declared_ident
        )

        return type_ident

    @property
    def default_type_ident(self) -> str:
        return self.t.named.qualified_name

    @cached_property
    def typestruct(self) -> "Alt[IdolPyCodegenTypeStruct]":
        return Alt(
            IdolPyCodegenTypeStruct(self, ts_decon) for ts_decon in self.t_decon.get_typestruct()
        )


class IdolPyCodegenEnum(GeneratorFileContext):
    codegen_file: IdolPyCodegenFile
    options: List[str]

    def __init__(self, codegen_file: IdolPyCodegenFile, options: List[str]):
        self.options = options
        self.codegen_file = codegen_file
        super(IdolPyCodegenEnum, self).__init__(codegen_file.parent, codegen_file.path)

    @cached_property
    def declared_ident(self) -> Alt[str]:
        def class_declaration(ident: str) -> List:
            enum_ident = self.state.import_ident(self.path, Exported(Path("enum"), "Enum"))

            return scripter.class_dec(ident, [enum_ident],
                                      [
                                          scripter.assignment(name.upper(), scripter.literal(name))
                                          for name in self.options
                                      ])

        return Alt.lift(
            self.state.add_content_with_ident(self.path,
                                              self.codegen_file.default_type_ident,
                                              class_declaration))


class IdolPyCodegenTypeStruct(GeneratorFileContext):
    codegen_file: IdolPyCodegenFile
    ts_decon: TypeStructDeconstructor

    @property
    def idol_py(self):
        return self.codegen_file.idol_py

    def __init__(self, parent: IdolPyCodegenFile, ts_decon: TypeStructDeconstructor):
        super(IdolPyCodegenTypeStruct, self).__init__(parent.parent, parent.path)
        self.ts_decon = ts_decon
        self.codegen_file = parent

    @cached_property
    def inner_scalar(self) -> "Alt[IdolPyCodegenScalar]":
        return Alt(
            IdolPyCodegenScalar(self, scalar_decon)
            for scalar_decon in Disjoint(
                self.ts_decon.get_scalar() + self.ts_decon.get_map() + self.ts_decon.get_repeated()
            )
        )

    @cached_property
    def declared_ident(self) -> Alt[Exported]:
        return Alt(
            Disjoint(
                Exported(
                    self.path,
                    self.state.add_content_with_ident(
                        self.path, self.codegen_file.default_type_ident,
                        scripter.declare_and_shadow(typing_expr, constructor_expr)
                    ),
                )
                for typing_expr in self.typing_expr
                for constructor_expr in self.container_constructor_expr
                if self.ts_decon.context.is_declarable
            )
            + Disjoint(
                declaration for scalar in self.inner_scalar for declaration in scalar.declared_ident
            )
        )

    @cached_property
    def typing_expr(self) -> Alt[str]:
        typing: Disjoint[str] = Disjoint(
            scripter.index_access(
                self.state.import_ident(self.path, Exported(Path("typing"), "List")),
                scalar_typing_expr)
            for scalar in self.inner_scalar
            for scalar_typing_expr in scalar.typing_expr
            if self.ts_decon.get_repeated()
        )

        typing += Disjoint(
            scripter.index_access(
                self.state.import_ident(self.path, Exported(Path("typing"), "List")),
                "str",
                scalar_typing_expr)
            for scalar in self.inner_scalar
            for scalar_typing_expr in scalar.typing_expr
            if self.ts_decon.get_repeated()
        )

        if typing:
            return Alt(typing)

        return Alt(expr for scalar in self.inner_scalar for expr in scalar.typing_expr)

    @cached_property
    def container_constructor_expr(self) -> Alt[str]:
        container_con: Disjoint[str] = self.ts_decon.get_repeated() and Disjoint.lift(
            self.state.import_ident(self.path, self.idol_py.idol_py_file.list))
        container_con += self.ts_decon.get_map() and Disjoint.lift(
            self.state.import_ident(self.path, self.idol_py.idol_py_file.map))

        return Alt(
            scripter.invocation(scripter.prop_access(con, "of"), scalar_con)
            for con in container_con
            for scalar in self.inner_scalar
            for scalar_con in scalar.constructor_expr
        )


class IdolPyCodegenScalar(GeneratorFileContext):
    typestruct: IdolPyCodegenTypeStruct
    scalar_dec: ScalarDeconstructor

    def __init__(self, parent: IdolPyCodegenTypeStruct, scalar_decon: ScalarDeconstructor):
        super(IdolPyCodegenScalar, self).__init__(parent.parent, parent.path)
        self.scalar_dec = scalar_decon

    @property
    def idol_py(self):
        return self.typestruct.idol_py

    @cached_property
    def typing_expr(self) -> Alt[str]:
        return Alt(Disjoint(self.imported_alias_ident) + Disjoint(self.prim_typing_expr))

    @cached_property
    def constructor_expr(self) -> Alt[str]:
        return Alt(Disjoint(self.imported_alias_ident) + Disjoint(self.prim_constructor_expr))

    @cached_property
    def imported_alias_ident(self) -> Alt[str]:
        # TODO: Import the scaffolded version if possible.
        1 / 0
        alias_codegen_file = Alt(
            self.idol_py.codegen_file(ref) for ref in self.scalar_dec.get_alias()
        )
        return Alt(
            self.state.import_ident(self.path, codegen_type,
                                    self.typestruct.codegen_file.default_type_ident)
            for codegen_file in alias_codegen_file
            for codegen_type in codegen_file.declared_type_ident
        )

    @cached_property
    def prim_constructor_expr(self) -> Alt[str]:
        constructor_expr: Disjoint[str] = Disjoint(
            scripter.invocation(
                self.state.import_ident(self.path, self.idol_py.idol_py_file.primitive),
                prim_expr,
            )
            for _ in self.scalar_dec.get_primitive()
            for prim_expr in self.prim_typing_expr
        )

        constructor_expr += Disjoint(
            scripter.invocation(
                self.state.import_ident(self.path, self.idol_py.idol_py_file.literal),
                scripter.literal(value),
            )
            for _, value in self.scalar_dec.get_literal()
        )

        return Alt(constructor_expr)

    @cached_property
    def prim_typing_expr(self) -> Alt[str]:
        scalar_prim = Disjoint(prim_type for prim_type in self.scalar_dec.get_primitive())
        scalar_prim += Disjoint(prim_type for prim_type, _ in self.scalar_dec.get_literal())

        return Alt(
            Disjoint(
                self.scalar_type_name_mappings[prim_type]
                for prim_type in scalar_prim
                if prim_type in self.scalar_type_name_mappings
            )
            + Disjoint(
                self.state.import_ident(self.path, Exported(Path("typing"), "Any"))
                for prim_type in scalar_prim
                if prim_type == PrimitiveType.ANY
            )
        )

    @cached_property
    def declared_prim_ident(self) -> Alt[Exported]:
        return Alt(
            Exported(
                self.path,
                self.state.add_content_with_ident(self.path,
                                                  self.typestruct.codegen_file.default_type_ident,
                                                  scripter.declare_and_shadow(
                                                      prim_expr, prim_con_expr
                                                  )),
            )
            for prim_expr in self.prim_typing_expr
            for prim_con_expr in self.prim_constructor_expr
            if not self.scalar_dec.context.is_declarable
        )

    @cached_property
    def declared_ident(self) -> Alt[Exported]:
        if not self.scalar_dec.context.is_declarable:
            return Alt.empty()

        return Alt(
            Disjoint(self.declared_prim_ident)
            + Disjoint(
                Exported(self.path, alias_ident) for alias_ident in self.imported_alias_ident
            )
        )

    scalar_type_name_mappings = {
        PrimitiveType.BOOL: "bool",
        PrimitiveType.INT: "int",
        PrimitiveType.STRING: "str",
        PrimitiveType.DOUBLE: "float",
    }


class IdolPyScaffoldFile:
    path: Path
    t: Type
    idol_py: IdolPy

    def __init__(self, idol_py: IdolPy, t: Type, path: Path):
        self.t = t
        self.path = path
        self.idol_py = idol_py

    @property
    def state(self) -> GeneratorAcc:
        return self.idol_py.state

    @cached_property
    def exported_type_ident(self) -> Alt[str]:
        type_decon = get_material_type_deconstructor(self.idol_py.config.params.all_types, self.t)

        return Alt(
            v
            for v in Disjoint(
                ident
                for ts_decon in type_decon.get_typestruct()
                for ident in self.generate_exported_typestruct(type_decon, ts_decon)
            )
        )

    def generate_exported_typestruct(
            self, type_decon: TypeDeconstructor, ts_decon: TypeStructDeconstructor
    ) -> Alt[str]:
        # For primitives, literals, and structures, just import the codegen literal.
        codegen_file = self.idol_py.codegen_file(type_decon.t.named)

        return Alt(
            self.state.add_content_with_ident(self.path, self.default_type_ident,
                                              scripter.assignable(
                                                  self.state.import_ident(self.path, codegen_type)))
            for codegen_type in codegen_file.declared_type_ident
        )

    @property
    def default_type_ident(self) -> str:
        return self.t.named.type_name

    def generate_type(self, ):
        type_dec = TypeDeconstructor(self.t)


class IdolPyFile(GeneratorFileContext):
    idol_py: IdolPy

    def __init__(self, idol_py: IdolPy, path: Path):
        self.idol_py = idol_py
        super(IdolPyFile, self).__init__(idol_py, path)

    @cached_property
    def dumped_file(self) -> Path:
        content = open(
            os.path.join(os.path.dirname(__file__), "__idol__.py"), encoding="utf-8"
        ).read()

        self.state.add_content(self.path, content)
        return self.path

    @cached_property
    def list(self) -> Exported:
        return Exported(self.dumped_file, "List")

    @cached_property
    def map(self) -> Exported:
        return Exported(self.dumped_file, "Map")

    @cached_property
    def primitive(self) -> Exported:
        return Exported(self.dumped_file, "Primitive")

    @cached_property
    def literal(self) -> Exported:
        return Exported(self.dumped_file, "Literal")

    @cached_property
    def enum(self) -> Exported:
        return Exported(self.dumped_file, "Enum")

    @cached_property
    def struct(self) -> Exported:
        return Exported(self.dumped_file, "Struct")


def main():
    params: GeneratorParams = start(
        CliConfig(
            args={
                "target": "idol module names whose contents will have extensible types scaffolded.",
                "output": "a directory to generate the scaffolds and codegen into.",
            }
        )
    )

    config = GeneratorConfig(params)
    config.with_path_mappings(
        dict(codegen=config.one_file_per_type, scaffold=config.one_file_per_type))

    idol_py = IdolPy(config)
    move_to = build(config, idol_py.render())
    move_to(params.output_dir)


if __name__ == "__main__":
    main()
